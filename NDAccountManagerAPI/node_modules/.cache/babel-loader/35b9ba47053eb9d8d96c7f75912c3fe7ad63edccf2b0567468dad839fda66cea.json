{"ast":null,"code":"/*! @azure/msal-browser v3.18.0 2024-07-01 */\n'use strict';\n\nimport { DEFAULT_CRYPTO_IMPLEMENTATION, buildStaticAuthorityOptions, PerformanceEvents, TimeUtils, OIDC_DEFAULT_SCOPES, AccountEntity } from '@azure/msal-common';\nimport { InteractionType, DEFAULT_REQUEST } from '../utils/BrowserConstants.mjs';\nimport { CryptoOps } from '../crypto/CryptoOps.mjs';\nimport { NestedAppAuthAdapter } from '../naa/mapping/NestedAppAuthAdapter.mjs';\nimport { NestedAppAuthError } from '../error/NestedAppAuthError.mjs';\nimport { EventHandler } from '../event/EventHandler.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER } from '../cache/BrowserCacheManager.mjs';\nimport { getAccount, setActiveAccount, getAllAccounts, getAccountByUsername, getAccountByHomeId, getAccountByLocalId, getActiveAccount } from '../cache/AccountManager.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass NestedAppAuthController {\n  constructor(operatingContext) {\n    this.operatingContext = operatingContext;\n    const proxy = this.operatingContext.getBridgeProxy();\n    if (proxy !== undefined) {\n      this.bridgeProxy = proxy;\n    } else {\n      throw new Error(\"unexpected: bridgeProxy is undefined\");\n    }\n    // Set the configuration.\n    this.config = operatingContext.getConfig();\n    // Initialize logger\n    this.logger = this.operatingContext.getLogger();\n    // Initialize performance client\n    this.performanceClient = this.config.telemetry.client;\n    // Initialize the crypto class.\n    this.browserCrypto = operatingContext.isBrowserEnvironment() ? new CryptoOps(this.logger, this.performanceClient) : DEFAULT_CRYPTO_IMPLEMENTATION;\n    // Initialize the browser storage class.\n    this.browserStorage = this.operatingContext.isBrowserEnvironment() ? new BrowserCacheManager(this.config.auth.clientId, this.config.cache, this.browserCrypto, this.logger, buildStaticAuthorityOptions(this.config.auth)) : DEFAULT_BROWSER_CACHE_MANAGER(this.config.auth.clientId, this.logger);\n    this.eventHandler = new EventHandler(this.logger, this.browserCrypto);\n    this.nestedAppAuthAdapter = new NestedAppAuthAdapter(this.config.auth.clientId, this.config.auth.clientCapabilities, this.browserCrypto, this.logger);\n    // Set the active account if available\n    const accountContext = this.bridgeProxy.getAccountContext();\n    if (accountContext) {\n      const cachedAccount = getAccount(accountContext, this.logger, this.browserStorage);\n      setActiveAccount(cachedAccount, this.browserStorage);\n    }\n  }\n  /**\n   * Returns the event handler instance\n   * @returns EventHandler\n   */\n  getEventHandler() {\n    return this.eventHandler;\n  }\n  /**\n   * Factory function to create a new instance of NestedAppAuthController\n   * @param operatingContext\n   * @returns Promise<IController>\n   */\n  static async createController(operatingContext) {\n    const controller = new NestedAppAuthController(operatingContext);\n    return Promise.resolve(controller);\n  }\n  /**\n   * Specific implementation of initialize function for NestedAppAuthController\n   * @returns\n   */\n  initialize() {\n    // do nothing not required by this controller\n    return Promise.resolve();\n  }\n  /**\n   * Validate the incoming request and add correlationId if not present\n   * @param request\n   * @returns\n   */\n  ensureValidRequest(request) {\n    if (request?.correlationId) {\n      return request;\n    }\n    return {\n      ...request,\n      correlationId: this.browserCrypto.createNewGuid()\n    };\n  }\n  /**\n   * Internal implementation of acquireTokenInteractive flow\n   * @param request\n   * @returns\n   */\n  async acquireTokenInteractive(request) {\n    const validRequest = this.ensureValidRequest(request);\n    this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Popup, validRequest);\n    const atPopupMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenPopup, validRequest.correlationId);\n    atPopupMeasurement?.add({\n      nestedAppAuthRequest: true\n    });\n    try {\n      const naaRequest = this.nestedAppAuthAdapter.toNaaTokenRequest(validRequest);\n      const reqTimestamp = TimeUtils.nowSeconds();\n      const response = await this.bridgeProxy.getTokenInteractive(naaRequest);\n      const result = this.nestedAppAuthAdapter.fromNaaTokenResponse(naaRequest, response, reqTimestamp);\n      // cache the tokens in the response\n      await this.hydrateCache(result, request);\n      this.browserStorage.setActiveAccount(result.account);\n      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Popup, result);\n      atPopupMeasurement.add({\n        accessTokenSize: result.accessToken.length,\n        idTokenSize: result.idToken.length\n      });\n      atPopupMeasurement.end({\n        success: true,\n        requestId: result.requestId\n      });\n      return result;\n    } catch (e) {\n      const error = this.nestedAppAuthAdapter.fromBridgeError(e);\n      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Popup, null, e);\n      atPopupMeasurement.end({\n        success: false\n      }, e);\n      throw error;\n    }\n  }\n  /**\n   * Internal implementation of acquireTokenSilent flow\n   * @param request\n   * @returns\n   */\n  async acquireTokenSilentInternal(request) {\n    const validRequest = this.ensureValidRequest(request);\n    this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Silent, validRequest);\n    // Look for tokens in the cache first\n    const result = await this.acquireTokenFromCache(validRequest);\n    if (result) {\n      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Silent, result);\n      return result;\n    }\n    // proceed with acquiring tokens via the host\n    const ssoSilentMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.SsoSilent, validRequest.correlationId);\n    ssoSilentMeasurement?.increment({\n      visibilityChangeCount: 0\n    });\n    ssoSilentMeasurement?.add({\n      nestedAppAuthRequest: true\n    });\n    try {\n      const naaRequest = this.nestedAppAuthAdapter.toNaaTokenRequest(validRequest);\n      const reqTimestamp = TimeUtils.nowSeconds();\n      const response = await this.bridgeProxy.getTokenSilent(naaRequest);\n      const result = this.nestedAppAuthAdapter.fromNaaTokenResponse(naaRequest, response, reqTimestamp);\n      // cache the tokens in the response\n      await this.hydrateCache(result, request);\n      this.browserStorage.setActiveAccount(result.account);\n      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Silent, result);\n      ssoSilentMeasurement?.add({\n        accessTokenSize: result.accessToken.length,\n        idTokenSize: result.idToken.length\n      });\n      ssoSilentMeasurement?.end({\n        success: true,\n        requestId: result.requestId\n      });\n      return result;\n    } catch (e) {\n      const error = this.nestedAppAuthAdapter.fromBridgeError(e);\n      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Silent, null, e);\n      ssoSilentMeasurement?.end({\n        success: false\n      }, e);\n      throw error;\n    }\n  }\n  /**\n   * acquires tokens from cache\n   * @param request\n   * @returns\n   */\n  async acquireTokenFromCache(request) {\n    const atsMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenSilent, request.correlationId);\n    atsMeasurement?.add({\n      nestedAppAuthRequest: true\n    });\n    const result = await this.acquireTokenFromCacheInternal(request);\n    if (result) {\n      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Silent, result);\n      atsMeasurement?.add({\n        accessTokenSize: result?.accessToken.length,\n        idTokenSize: result?.idToken.length\n      });\n      atsMeasurement?.end({\n        success: true\n      });\n      return result;\n    }\n    this.logger.error(\"Cached tokens are not found for the account, proceeding with silent token request.\");\n    this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Silent, null);\n    atsMeasurement?.end({\n      success: false\n    });\n    return null;\n  }\n  /**\n   *\n   * @param request\n   * @returns\n   */\n  async acquireTokenFromCacheInternal(request) {\n    const accountContext = this.bridgeProxy.getAccountContext();\n    let currentAccount = null;\n    if (accountContext) {\n      const hubAccount = getAccount(accountContext, this.logger, this.browserStorage);\n      // always prioritize for hub account context, the reqirement of `request.account` will be removed soon\n      currentAccount = hubAccount || request.account;\n    }\n    // fall back to brokering if no cached account is found\n    if (!currentAccount) {\n      this.logger.verbose(\"No active account found, falling back to the host\");\n      return Promise.resolve(null);\n    }\n    this.logger.verbose(\"active account found, attempting to acquire token silently\");\n    const authRequest = {\n      ...request,\n      correlationId: request.correlationId || this.browserCrypto.createNewGuid(),\n      authority: request.authority || currentAccount.environment,\n      scopes: request.scopes?.length ? request.scopes : [...OIDC_DEFAULT_SCOPES]\n    };\n    // fetch access token and check for expiry\n    const tokenKeys = this.browserStorage.getTokenKeys();\n    const cachedAccessToken = this.browserStorage.getAccessToken(currentAccount, authRequest, tokenKeys, currentAccount.tenantId, this.performanceClient, authRequest.correlationId);\n    // If there is no access token, log it and return null\n    if (!cachedAccessToken) {\n      this.logger.verbose(\"No cached access token found\");\n      return Promise.resolve(null);\n      // If access token has expired, remove the token from cache and return null\n    } else if (TimeUtils.wasClockTurnedBack(cachedAccessToken.cachedAt) || TimeUtils.isTokenExpired(cachedAccessToken.expiresOn, this.config.system.tokenRenewalOffsetSeconds)) {\n      this.logger.verbose(\"Cached access token has expired, deleting all related tokens from cache\");\n      const accountEntity = AccountEntity.createFromAccountInfo(currentAccount);\n      await this.browserStorage.removeAccountContext(accountEntity);\n      return Promise.resolve(null);\n    }\n    const cachedIdToken = this.browserStorage.getIdToken(currentAccount, tokenKeys, currentAccount.tenantId, this.performanceClient, authRequest.correlationId);\n    if (!cachedIdToken) {\n      this.logger.verbose(\"No cached id token found\");\n      return Promise.resolve(null);\n    }\n    return this.nestedAppAuthAdapter.toAuthenticationResultFromCache(currentAccount, cachedIdToken, cachedAccessToken, authRequest, authRequest.correlationId);\n  }\n  /**\n   * acquireTokenPopup flow implementation\n   * @param request\n   * @returns\n   */\n  async acquireTokenPopup(request) {\n    return this.acquireTokenInteractive(request);\n  }\n  /**\n   * acquireTokenRedirect flow is not supported in nested app auth\n   * @param request\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  acquireTokenRedirect(request) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  /**\n   * acquireTokenSilent flow implementation\n   * @param silentRequest\n   * @returns\n   */\n  async acquireTokenSilent(silentRequest) {\n    return this.acquireTokenSilentInternal(silentRequest);\n  }\n  /**\n   * Hybrid flow is not currently supported in nested app auth\n   * @param request\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  acquireTokenByCode(request // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  /**\n   * acquireTokenNative flow is not currently supported in nested app auth\n   * @param request\n   * @param apiId\n   * @param accountId\n   */\n  acquireTokenNative(request, apiId,\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  accountId // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  /**\n   * acquireTokenByRefreshToken flow is not currently supported in nested app auth\n   * @param commonRequest\n   * @param silentRequest\n   */\n  acquireTokenByRefreshToken(commonRequest,\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  silentRequest // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  /**\n   * Adds event callbacks to array\n   * @param callback\n   */\n  addEventCallback(callback) {\n    return this.eventHandler.addEventCallback(callback);\n  }\n  /**\n   * Removes callback with provided id from callback array\n   * @param callbackId\n   */\n  removeEventCallback(callbackId) {\n    this.eventHandler.removeEventCallback(callbackId);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  addPerformanceCallback(callback) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  removePerformanceCallback(callbackId) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  enableAccountStorageEvents() {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  disableAccountStorageEvents() {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  // #region Account APIs\n  /**\n   * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.\n   * @param accountFilter - (Optional) filter to narrow down the accounts returned\n   * @returns Array of AccountInfo objects in cache\n   */\n  getAllAccounts(accountFilter) {\n    return getAllAccounts(this.logger, this.browserStorage, this.isBrowserEnv(), accountFilter);\n  }\n  /**\n   * Returns the first account found in the cache that matches the account filter passed in.\n   * @param accountFilter\n   * @returns The first account found in the cache matching the provided filter or null if no account could be found.\n   */\n  getAccount(accountFilter) {\n    return getAccount(accountFilter, this.logger, this.browserStorage);\n  }\n  /**\n   * Returns the signed in account matching username.\n   * (the account object is created at the time of successful login)\n   * or null when no matching account is found.\n   * This API is provided for convenience but getAccountById should be used for best reliability\n   * @param username\n   * @returns The account object stored in MSAL\n   */\n  getAccountByUsername(username) {\n    return getAccountByUsername(username, this.logger, this.browserStorage);\n  }\n  /**\n   * Returns the signed in account matching homeAccountId.\n   * (the account object is created at the time of successful login)\n   * or null when no matching account is found\n   * @param homeAccountId\n   * @returns The account object stored in MSAL\n   */\n  getAccountByHomeId(homeAccountId) {\n    return getAccountByHomeId(homeAccountId, this.logger, this.browserStorage);\n  }\n  /**\n   * Returns the signed in account matching localAccountId.\n   * (the account object is created at the time of successful login)\n   * or null when no matching account is found\n   * @param localAccountId\n   * @returns The account object stored in MSAL\n   */\n  getAccountByLocalId(localAccountId) {\n    return getAccountByLocalId(localAccountId, this.logger, this.browserStorage);\n  }\n  /**\n   * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.\n   * @param account\n   */\n  setActiveAccount(account) {\n    /*\n     * StandardController uses this to allow the developer to set the active account\n     * in the nested app auth scenario the active account is controlled by the app hosting the nested app\n     */\n    return setActiveAccount(account, this.browserStorage);\n  }\n  /**\n   * Gets the currently active account\n   */\n  getActiveAccount() {\n    return getActiveAccount(this.browserStorage);\n  }\n  // #endregion\n  handleRedirectPromise(hash // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    return Promise.resolve(null);\n  }\n  loginPopup(request // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    return this.acquireTokenInteractive(request || DEFAULT_REQUEST);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  loginRedirect(request) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  logout(logoutRequest) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  logoutRedirect(logoutRequest // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  logoutPopup(logoutRequest // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  ssoSilent(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  request) {\n    return this.acquireTokenSilentInternal(request);\n  }\n  getTokenCache() {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  /**\n   * Returns the logger instance\n   */\n  getLogger() {\n    return this.logger;\n  }\n  /**\n   * Replaces the default logger set in configurations with new Logger with new configurations\n   * @param logger Logger instance\n   */\n  setLogger(logger) {\n    this.logger = logger;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  initializeWrapperLibrary(sku, version) {\n    /*\n     * Standard controller uses this to set the sku and version of the wrapper library in the storage\n     * we do nothing here\n     */\n    return;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  setNavigationClient(navigationClient) {\n    this.logger.warning(\"setNavigationClient is not supported in nested app auth\");\n  }\n  getConfiguration() {\n    return this.config;\n  }\n  isBrowserEnv() {\n    return this.operatingContext.isBrowserEnvironment();\n  }\n  getBrowserCrypto() {\n    return this.browserCrypto;\n  }\n  getPerformanceClient() {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  getRedirectResponse() {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async clearCache(logoutRequest) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  async hydrateCache(result, request) {\n    this.logger.verbose(\"hydrateCache called\");\n    const accountEntity = AccountEntity.createFromAccountInfo(result.account, result.cloudGraphHostName, result.msGraphHost);\n    this.browserStorage.setAccount(accountEntity);\n    return this.browserStorage.hydrateCache(result, request);\n  }\n}\nexport { NestedAppAuthController };","map":{"version":3,"names":["NestedAppAuthController","constructor","operatingContext","proxy","getBridgeProxy","undefined","bridgeProxy","Error","config","getConfig","logger","getLogger","performanceClient","telemetry","client","browserCrypto","isBrowserEnvironment","CryptoOps","DEFAULT_CRYPTO_IMPLEMENTATION","browserStorage","BrowserCacheManager","auth","clientId","cache","buildStaticAuthorityOptions","DEFAULT_BROWSER_CACHE_MANAGER","eventHandler","EventHandler","nestedAppAuthAdapter","NestedAppAuthAdapter","clientCapabilities","accountContext","getAccountContext","cachedAccount","getAccount","setActiveAccount","getEventHandler","createController","controller","Promise","resolve","initialize","ensureValidRequest","request","correlationId","createNewGuid","acquireTokenInteractive","validRequest","emitEvent","EventType","ACQUIRE_TOKEN_START","InteractionType","Popup","atPopupMeasurement","startMeasurement","PerformanceEvents","AcquireTokenPopup","add","nestedAppAuthRequest","naaRequest","toNaaTokenRequest","reqTimestamp","TimeUtils","nowSeconds","response","getTokenInteractive","result","fromNaaTokenResponse","hydrateCache","account","ACQUIRE_TOKEN_SUCCESS","accessTokenSize","accessToken","length","idTokenSize","idToken","end","success","requestId","e","error","fromBridgeError","ACQUIRE_TOKEN_FAILURE","acquireTokenSilentInternal","Silent","acquireTokenFromCache","ssoSilentMeasurement","SsoSilent","increment","visibilityChangeCount","getTokenSilent","atsMeasurement","AcquireTokenSilent","acquireTokenFromCacheInternal","currentAccount","hubAccount","verbose","authRequest","authority","environment","scopes","OIDC_DEFAULT_SCOPES","tokenKeys","getTokenKeys","cachedAccessToken","getAccessToken","tenantId","wasClockTurnedBack","cachedAt","isTokenExpired","expiresOn","system","tokenRenewalOffsetSeconds","accountEntity","AccountEntity","createFromAccountInfo","removeAccountContext","cachedIdToken","getIdToken","toAuthenticationResultFromCache","acquireTokenPopup","acquireTokenRedirect","NestedAppAuthError","createUnsupportedError","acquireTokenSilent","silentRequest","acquireTokenByCode","acquireTokenNative","apiId","accountId","acquireTokenByRefreshToken","commonRequest","addEventCallback","callback","removeEventCallback","callbackId","addPerformanceCallback","removePerformanceCallback","enableAccountStorageEvents","disableAccountStorageEvents","getAllAccounts","accountFilter","isBrowserEnv","getAccountByUsername","username","getAccountByHomeId","homeAccountId","getAccountByLocalId","localAccountId","getActiveAccount","handleRedirectPromise","hash","loginPopup","DEFAULT_REQUEST","loginRedirect","logout","logoutRequest","logoutRedirect","logoutPopup","ssoSilent","getTokenCache","setLogger","initializeWrapperLibrary","sku","version","setNavigationClient","navigationClient","warning","getConfiguration","getBrowserCrypto","getPerformanceClient","getRedirectResponse","clearCache","cloudGraphHostName","msGraphHost","setAccount"],"sources":["C:\\Users\\90542\\ndaccountmanager\\node_modules\\@azure\\msal-browser\\src\\controllers\\NestedAppAuthController.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    CommonAuthorizationUrlRequest,\n    CommonSilentFlowRequest,\n    PerformanceCallbackFunction,\n    AccountInfo,\n    Logger,\n    ICrypto,\n    IPerformanceClient,\n    DEFAULT_CRYPTO_IMPLEMENTATION,\n    PerformanceEvents,\n    TimeUtils,\n    buildStaticAuthorityOptions,\n    AccountEntity,\n    OIDC_DEFAULT_SCOPES,\n    BaseAuthRequest,\n    AccountFilter,\n} from \"@azure/msal-common\";\nimport { ITokenCache } from \"../cache/ITokenCache\";\nimport { BrowserConfiguration } from \"../config/Configuration\";\nimport { INavigationClient } from \"../navigation/INavigationClient\";\nimport { AuthorizationCodeRequest } from \"../request/AuthorizationCodeRequest\";\nimport { EndSessionPopupRequest } from \"../request/EndSessionPopupRequest\";\nimport { EndSessionRequest } from \"../request/EndSessionRequest\";\nimport { PopupRequest } from \"../request/PopupRequest\";\nimport { RedirectRequest } from \"../request/RedirectRequest\";\nimport { SilentRequest } from \"../request/SilentRequest\";\nimport { SsoSilentRequest } from \"../request/SsoSilentRequest\";\nimport {\n    ApiId,\n    WrapperSKU,\n    InteractionType,\n    DEFAULT_REQUEST,\n} from \"../utils/BrowserConstants\";\nimport { IController } from \"./IController\";\nimport { NestedAppOperatingContext } from \"../operatingcontext/NestedAppOperatingContext\";\nimport { IBridgeProxy } from \"../naa/IBridgeProxy\";\nimport { CryptoOps } from \"../crypto/CryptoOps\";\nimport { NestedAppAuthAdapter } from \"../naa/mapping/NestedAppAuthAdapter\";\nimport { NestedAppAuthError } from \"../error/NestedAppAuthError\";\nimport { EventHandler } from \"../event/EventHandler\";\nimport { EventType } from \"../event/EventType\";\nimport { EventCallbackFunction, EventError } from \"../event/EventMessage\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\nimport {\n    BrowserCacheManager,\n    DEFAULT_BROWSER_CACHE_MANAGER,\n} from \"../cache/BrowserCacheManager\";\nimport { ClearCacheRequest } from \"../request/ClearCacheRequest\";\nimport * as AccountManager from \"../cache/AccountManager\";\n\nexport class NestedAppAuthController implements IController {\n    // OperatingContext\n    protected readonly operatingContext: NestedAppOperatingContext;\n\n    // BridgeProxy\n    protected readonly bridgeProxy: IBridgeProxy;\n\n    // Crypto interface implementation\n    protected readonly browserCrypto: ICrypto;\n\n    // Input configuration by developer/user\n    protected readonly config: BrowserConfiguration;\n\n    // Storage interface implementation\n    protected readonly browserStorage!: BrowserCacheManager;\n\n    // Logger\n    protected logger: Logger;\n\n    // Performance telemetry client\n    protected readonly performanceClient: IPerformanceClient;\n\n    // EventHandler\n    protected readonly eventHandler: EventHandler;\n\n    // NestedAppAuthAdapter\n    protected readonly nestedAppAuthAdapter: NestedAppAuthAdapter;\n\n    constructor(operatingContext: NestedAppOperatingContext) {\n        this.operatingContext = operatingContext;\n        const proxy = this.operatingContext.getBridgeProxy();\n        if (proxy !== undefined) {\n            this.bridgeProxy = proxy;\n        } else {\n            throw new Error(\"unexpected: bridgeProxy is undefined\");\n        }\n\n        // Set the configuration.\n        this.config = operatingContext.getConfig();\n\n        // Initialize logger\n        this.logger = this.operatingContext.getLogger();\n\n        // Initialize performance client\n        this.performanceClient = this.config.telemetry.client;\n\n        // Initialize the crypto class.\n        this.browserCrypto = operatingContext.isBrowserEnvironment()\n            ? new CryptoOps(this.logger, this.performanceClient)\n            : DEFAULT_CRYPTO_IMPLEMENTATION;\n\n        // Initialize the browser storage class.\n        this.browserStorage = this.operatingContext.isBrowserEnvironment()\n            ? new BrowserCacheManager(\n                  this.config.auth.clientId,\n                  this.config.cache,\n                  this.browserCrypto,\n                  this.logger,\n                  buildStaticAuthorityOptions(this.config.auth)\n              )\n            : DEFAULT_BROWSER_CACHE_MANAGER(\n                  this.config.auth.clientId,\n                  this.logger\n              );\n\n        this.eventHandler = new EventHandler(this.logger, this.browserCrypto);\n\n        this.nestedAppAuthAdapter = new NestedAppAuthAdapter(\n            this.config.auth.clientId,\n            this.config.auth.clientCapabilities,\n            this.browserCrypto,\n            this.logger\n        );\n\n        // Set the active account if available\n        const accountContext = this.bridgeProxy.getAccountContext();\n        if (accountContext) {\n            const cachedAccount = AccountManager.getAccount(\n                accountContext,\n                this.logger,\n                this.browserStorage\n            );\n\n            AccountManager.setActiveAccount(cachedAccount, this.browserStorage);\n        }\n    }\n\n    /**\n     * Returns the event handler instance\n     * @returns EventHandler\n     */\n    getEventHandler(): EventHandler {\n        return this.eventHandler;\n    }\n\n    /**\n     * Factory function to create a new instance of NestedAppAuthController\n     * @param operatingContext\n     * @returns Promise<IController>\n     */\n    static async createController(\n        operatingContext: NestedAppOperatingContext\n    ): Promise<IController> {\n        const controller = new NestedAppAuthController(operatingContext);\n        return Promise.resolve(controller);\n    }\n\n    /**\n     * Specific implementation of initialize function for NestedAppAuthController\n     * @returns\n     */\n    initialize(): Promise<void> {\n        // do nothing not required by this controller\n        return Promise.resolve();\n    }\n\n    /**\n     * Validate the incoming request and add correlationId if not present\n     * @param request\n     * @returns\n     */\n    private ensureValidRequest<\n        T extends\n            | SsoSilentRequest\n            | SilentRequest\n            | PopupRequest\n            | RedirectRequest\n    >(request: T): T {\n        if (request?.correlationId) {\n            return request;\n        }\n        return {\n            ...request,\n            correlationId: this.browserCrypto.createNewGuid(),\n        };\n    }\n\n    /**\n     * Internal implementation of acquireTokenInteractive flow\n     * @param request\n     * @returns\n     */\n    private async acquireTokenInteractive(\n        request: PopupRequest | RedirectRequest\n    ): Promise<AuthenticationResult> {\n        const validRequest = this.ensureValidRequest(request);\n\n        this.eventHandler.emitEvent(\n            EventType.ACQUIRE_TOKEN_START,\n            InteractionType.Popup,\n            validRequest\n        );\n\n        const atPopupMeasurement = this.performanceClient.startMeasurement(\n            PerformanceEvents.AcquireTokenPopup,\n            validRequest.correlationId\n        );\n\n        atPopupMeasurement?.add({ nestedAppAuthRequest: true });\n\n        try {\n            const naaRequest =\n                this.nestedAppAuthAdapter.toNaaTokenRequest(validRequest);\n            const reqTimestamp = TimeUtils.nowSeconds();\n            const response = await this.bridgeProxy.getTokenInteractive(\n                naaRequest\n            );\n            const result: AuthenticationResult =\n                this.nestedAppAuthAdapter.fromNaaTokenResponse(\n                    naaRequest,\n                    response,\n                    reqTimestamp\n                );\n\n            // cache the tokens in the response\n            await this.hydrateCache(result, request);\n\n            this.browserStorage.setActiveAccount(result.account);\n            this.eventHandler.emitEvent(\n                EventType.ACQUIRE_TOKEN_SUCCESS,\n                InteractionType.Popup,\n                result\n            );\n\n            atPopupMeasurement.add({\n                accessTokenSize: result.accessToken.length,\n                idTokenSize: result.idToken.length,\n            });\n\n            atPopupMeasurement.end({\n                success: true,\n                requestId: result.requestId,\n            });\n\n            return result;\n        } catch (e) {\n            const error = this.nestedAppAuthAdapter.fromBridgeError(e);\n            this.eventHandler.emitEvent(\n                EventType.ACQUIRE_TOKEN_FAILURE,\n                InteractionType.Popup,\n                null,\n                e as EventError\n            );\n\n            atPopupMeasurement.end(\n                {\n                    success: false,\n                },\n                e\n            );\n\n            throw error;\n        }\n    }\n\n    /**\n     * Internal implementation of acquireTokenSilent flow\n     * @param request\n     * @returns\n     */\n    private async acquireTokenSilentInternal(\n        request: SilentRequest\n    ): Promise<AuthenticationResult> {\n        const validRequest = this.ensureValidRequest(request);\n        this.eventHandler.emitEvent(\n            EventType.ACQUIRE_TOKEN_START,\n            InteractionType.Silent,\n            validRequest\n        );\n\n        // Look for tokens in the cache first\n        const result = await this.acquireTokenFromCache(validRequest);\n\n        if (result) {\n            this.eventHandler.emitEvent(\n                EventType.ACQUIRE_TOKEN_SUCCESS,\n                InteractionType.Silent,\n                result\n            );\n            return result;\n        }\n\n        // proceed with acquiring tokens via the host\n        const ssoSilentMeasurement = this.performanceClient.startMeasurement(\n            PerformanceEvents.SsoSilent,\n            validRequest.correlationId\n        );\n\n        ssoSilentMeasurement?.increment({\n            visibilityChangeCount: 0,\n        });\n\n        ssoSilentMeasurement?.add({\n            nestedAppAuthRequest: true,\n        });\n\n        try {\n            const naaRequest =\n                this.nestedAppAuthAdapter.toNaaTokenRequest(validRequest);\n            const reqTimestamp = TimeUtils.nowSeconds();\n            const response = await this.bridgeProxy.getTokenSilent(naaRequest);\n\n            const result: AuthenticationResult =\n                this.nestedAppAuthAdapter.fromNaaTokenResponse(\n                    naaRequest,\n                    response,\n                    reqTimestamp\n                );\n\n            // cache the tokens in the response\n            await this.hydrateCache(result, request);\n\n            this.browserStorage.setActiveAccount(result.account);\n            this.eventHandler.emitEvent(\n                EventType.ACQUIRE_TOKEN_SUCCESS,\n                InteractionType.Silent,\n                result\n            );\n            ssoSilentMeasurement?.add({\n                accessTokenSize: result.accessToken.length,\n                idTokenSize: result.idToken.length,\n            });\n            ssoSilentMeasurement?.end({\n                success: true,\n                requestId: result.requestId,\n            });\n            return result;\n        } catch (e) {\n            const error = this.nestedAppAuthAdapter.fromBridgeError(e);\n            this.eventHandler.emitEvent(\n                EventType.ACQUIRE_TOKEN_FAILURE,\n                InteractionType.Silent,\n                null,\n                e as EventError\n            );\n            ssoSilentMeasurement?.end(\n                {\n                    success: false,\n                },\n                e\n            );\n            throw error;\n        }\n    }\n\n    /**\n     * acquires tokens from cache\n     * @param request\n     * @returns\n     */\n    private async acquireTokenFromCache(\n        request: SilentRequest\n    ): Promise<AuthenticationResult | null> {\n        const atsMeasurement = this.performanceClient.startMeasurement(\n            PerformanceEvents.AcquireTokenSilent,\n            request.correlationId\n        );\n\n        atsMeasurement?.add({\n            nestedAppAuthRequest: true,\n        });\n\n        const result = await this.acquireTokenFromCacheInternal(request);\n\n        if (result) {\n            this.eventHandler.emitEvent(\n                EventType.ACQUIRE_TOKEN_SUCCESS,\n                InteractionType.Silent,\n                result\n            );\n            atsMeasurement?.add({\n                accessTokenSize: result?.accessToken.length,\n                idTokenSize: result?.idToken.length,\n            });\n            atsMeasurement?.end({\n                success: true,\n            });\n            return result;\n        }\n\n        this.logger.error(\n            \"Cached tokens are not found for the account, proceeding with silent token request.\"\n        );\n\n        this.eventHandler.emitEvent(\n            EventType.ACQUIRE_TOKEN_FAILURE,\n            InteractionType.Silent,\n            null\n        );\n        atsMeasurement?.end({\n            success: false,\n        });\n\n        return null;\n    }\n\n    /**\n     *\n     * @param request\n     * @returns\n     */\n    private async acquireTokenFromCacheInternal(\n        request: SilentRequest\n    ): Promise<AuthenticationResult | null> {\n        const accountContext = this.bridgeProxy.getAccountContext();\n        let currentAccount = null;\n        if (accountContext) {\n            const hubAccount = AccountManager.getAccount(\n                accountContext,\n                this.logger,\n                this.browserStorage\n            );\n            // always prioritize for hub account context, the reqirement of `request.account` will be removed soon\n            currentAccount = hubAccount || request.account;\n        }\n\n        // fall back to brokering if no cached account is found\n        if (!currentAccount) {\n            this.logger.verbose(\n                \"No active account found, falling back to the host\"\n            );\n            return Promise.resolve(null);\n        }\n\n        this.logger.verbose(\n            \"active account found, attempting to acquire token silently\"\n        );\n\n        const authRequest: BaseAuthRequest = {\n            ...request,\n            correlationId:\n                request.correlationId || this.browserCrypto.createNewGuid(),\n            authority: request.authority || currentAccount.environment,\n            scopes: request.scopes?.length\n                ? request.scopes\n                : [...OIDC_DEFAULT_SCOPES],\n        };\n\n        // fetch access token and check for expiry\n        const tokenKeys = this.browserStorage.getTokenKeys();\n        const cachedAccessToken = this.browserStorage.getAccessToken(\n            currentAccount,\n            authRequest,\n            tokenKeys,\n            currentAccount.tenantId,\n            this.performanceClient,\n            authRequest.correlationId\n        );\n\n        // If there is no access token, log it and return null\n        if (!cachedAccessToken) {\n            this.logger.verbose(\"No cached access token found\");\n            return Promise.resolve(null);\n            // If access token has expired, remove the token from cache and return null\n        } else if (\n            TimeUtils.wasClockTurnedBack(cachedAccessToken.cachedAt) ||\n            TimeUtils.isTokenExpired(\n                cachedAccessToken.expiresOn,\n                this.config.system.tokenRenewalOffsetSeconds\n            )\n        ) {\n            this.logger.verbose(\n                \"Cached access token has expired, deleting all related tokens from cache\"\n            );\n            const accountEntity =\n                AccountEntity.createFromAccountInfo(currentAccount);\n            await this.browserStorage.removeAccountContext(accountEntity);\n            return Promise.resolve(null);\n        }\n\n        const cachedIdToken = this.browserStorage.getIdToken(\n            currentAccount,\n            tokenKeys,\n            currentAccount.tenantId,\n            this.performanceClient,\n            authRequest.correlationId\n        );\n\n        if (!cachedIdToken) {\n            this.logger.verbose(\"No cached id token found\");\n            return Promise.resolve(null);\n        }\n\n        return this.nestedAppAuthAdapter.toAuthenticationResultFromCache(\n            currentAccount,\n            cachedIdToken,\n            cachedAccessToken,\n            authRequest,\n            authRequest.correlationId\n        );\n    }\n\n    /**\n     * acquireTokenPopup flow implementation\n     * @param request\n     * @returns\n     */\n    async acquireTokenPopup(\n        request: PopupRequest\n    ): Promise<AuthenticationResult> {\n        return this.acquireTokenInteractive(request);\n    }\n\n    /**\n     * acquireTokenRedirect flow is not supported in nested app auth\n     * @param request\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    acquireTokenRedirect(request: RedirectRequest): Promise<void> {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n\n    /**\n     * acquireTokenSilent flow implementation\n     * @param silentRequest\n     * @returns\n     */\n    async acquireTokenSilent(\n        silentRequest: SilentRequest\n    ): Promise<AuthenticationResult> {\n        return this.acquireTokenSilentInternal(silentRequest);\n    }\n\n    /**\n     * Hybrid flow is not currently supported in nested app auth\n     * @param request\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    acquireTokenByCode(\n        request: AuthorizationCodeRequest // eslint-disable-line @typescript-eslint/no-unused-vars\n    ): Promise<AuthenticationResult> {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n\n    /**\n     * acquireTokenNative flow is not currently supported in nested app auth\n     * @param request\n     * @param apiId\n     * @param accountId\n     */\n    acquireTokenNative(\n        request: // eslint-disable-line @typescript-eslint/no-unused-vars\n        | SilentRequest\n            | Partial<\n                  Omit<\n                      CommonAuthorizationUrlRequest,\n                      | \"requestedClaimsHash\"\n                      | \"responseMode\"\n                      | \"codeChallenge\"\n                      | \"codeChallengeMethod\"\n                      | \"nativeBroker\"\n                  >\n              >\n            | PopupRequest,\n        apiId: ApiId, // eslint-disable-line @typescript-eslint/no-unused-vars\n        accountId?: string | undefined // eslint-disable-line @typescript-eslint/no-unused-vars\n    ): Promise<AuthenticationResult> {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n\n    /**\n     * acquireTokenByRefreshToken flow is not currently supported in nested app auth\n     * @param commonRequest\n     * @param silentRequest\n     */\n    acquireTokenByRefreshToken(\n        commonRequest: CommonSilentFlowRequest, // eslint-disable-line @typescript-eslint/no-unused-vars\n        silentRequest: SilentRequest // eslint-disable-line @typescript-eslint/no-unused-vars\n    ): Promise<AuthenticationResult> {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n\n    /**\n     * Adds event callbacks to array\n     * @param callback\n     */\n    addEventCallback(callback: EventCallbackFunction): string | null {\n        return this.eventHandler.addEventCallback(callback);\n    }\n\n    /**\n     * Removes callback with provided id from callback array\n     * @param callbackId\n     */\n    removeEventCallback(callbackId: string): void {\n        this.eventHandler.removeEventCallback(callbackId);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    addPerformanceCallback(callback: PerformanceCallbackFunction): string {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    removePerformanceCallback(callbackId: string): boolean {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n\n    enableAccountStorageEvents(): void {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n\n    disableAccountStorageEvents(): void {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n\n    // #region Account APIs\n\n    /**\n     * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.\n     * @param accountFilter - (Optional) filter to narrow down the accounts returned\n     * @returns Array of AccountInfo objects in cache\n     */\n    getAllAccounts(accountFilter?: AccountFilter): AccountInfo[] {\n        return AccountManager.getAllAccounts(\n            this.logger,\n            this.browserStorage,\n            this.isBrowserEnv(),\n            accountFilter\n        );\n    }\n\n    /**\n     * Returns the first account found in the cache that matches the account filter passed in.\n     * @param accountFilter\n     * @returns The first account found in the cache matching the provided filter or null if no account could be found.\n     */\n    getAccount(accountFilter: AccountFilter): AccountInfo | null {\n        return AccountManager.getAccount(\n            accountFilter,\n            this.logger,\n            this.browserStorage\n        );\n    }\n\n    /**\n     * Returns the signed in account matching username.\n     * (the account object is created at the time of successful login)\n     * or null when no matching account is found.\n     * This API is provided for convenience but getAccountById should be used for best reliability\n     * @param username\n     * @returns The account object stored in MSAL\n     */\n    getAccountByUsername(username: string): AccountInfo | null {\n        return AccountManager.getAccountByUsername(\n            username,\n            this.logger,\n            this.browserStorage\n        );\n    }\n\n    /**\n     * Returns the signed in account matching homeAccountId.\n     * (the account object is created at the time of successful login)\n     * or null when no matching account is found\n     * @param homeAccountId\n     * @returns The account object stored in MSAL\n     */\n    getAccountByHomeId(homeAccountId: string): AccountInfo | null {\n        return AccountManager.getAccountByHomeId(\n            homeAccountId,\n            this.logger,\n            this.browserStorage\n        );\n    }\n\n    /**\n     * Returns the signed in account matching localAccountId.\n     * (the account object is created at the time of successful login)\n     * or null when no matching account is found\n     * @param localAccountId\n     * @returns The account object stored in MSAL\n     */\n    getAccountByLocalId(localAccountId: string): AccountInfo | null {\n        return AccountManager.getAccountByLocalId(\n            localAccountId,\n            this.logger,\n            this.browserStorage\n        );\n    }\n\n    /**\n     * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.\n     * @param account\n     */\n    setActiveAccount(account: AccountInfo | null): void {\n        /*\n         * StandardController uses this to allow the developer to set the active account\n         * in the nested app auth scenario the active account is controlled by the app hosting the nested app\n         */\n        return AccountManager.setActiveAccount(account, this.browserStorage);\n    }\n\n    /**\n     * Gets the currently active account\n     */\n    getActiveAccount(): AccountInfo | null {\n        return AccountManager.getActiveAccount(this.browserStorage);\n    }\n\n    // #endregion\n\n    handleRedirectPromise(\n        hash?: string | undefined // eslint-disable-line @typescript-eslint/no-unused-vars\n    ): Promise<AuthenticationResult | null> {\n        return Promise.resolve(null);\n    }\n    loginPopup(\n        request?: PopupRequest | undefined // eslint-disable-line @typescript-eslint/no-unused-vars\n    ): Promise<AuthenticationResult> {\n        return this.acquireTokenInteractive(request || DEFAULT_REQUEST);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    loginRedirect(request?: RedirectRequest | undefined): Promise<void> {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    logout(logoutRequest?: EndSessionRequest | undefined): Promise<void> {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n    logoutRedirect(\n        logoutRequest?: EndSessionRequest | undefined // eslint-disable-line @typescript-eslint/no-unused-vars\n    ): Promise<void> {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n    logoutPopup(\n        logoutRequest?: EndSessionPopupRequest | undefined // eslint-disable-line @typescript-eslint/no-unused-vars\n    ): Promise<void> {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n    ssoSilent(\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        request: Partial<\n            Omit<\n                CommonAuthorizationUrlRequest,\n                | \"requestedClaimsHash\"\n                | \"responseMode\"\n                | \"codeChallenge\"\n                | \"codeChallengeMethod\"\n                | \"nativeBroker\"\n            >\n        >\n    ): Promise<AuthenticationResult> {\n        return this.acquireTokenSilentInternal(request as SilentRequest);\n    }\n    getTokenCache(): ITokenCache {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n\n    /**\n     * Returns the logger instance\n     */\n    public getLogger(): Logger {\n        return this.logger;\n    }\n\n    /**\n     * Replaces the default logger set in configurations with new Logger with new configurations\n     * @param logger Logger instance\n     */\n    setLogger(logger: Logger): void {\n        this.logger = logger;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    initializeWrapperLibrary(sku: WrapperSKU, version: string): void {\n        /*\n         * Standard controller uses this to set the sku and version of the wrapper library in the storage\n         * we do nothing here\n         */\n        return;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setNavigationClient(navigationClient: INavigationClient): void {\n        this.logger.warning(\n            \"setNavigationClient is not supported in nested app auth\"\n        );\n    }\n\n    getConfiguration(): BrowserConfiguration {\n        return this.config;\n    }\n\n    isBrowserEnv(): boolean {\n        return this.operatingContext.isBrowserEnvironment();\n    }\n\n    getBrowserCrypto(): ICrypto {\n        return this.browserCrypto;\n    }\n\n    getPerformanceClient(): IPerformanceClient {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n\n    getRedirectResponse(): Map<string, Promise<AuthenticationResult | null>> {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async clearCache(logoutRequest?: ClearCacheRequest): Promise<void> {\n        throw NestedAppAuthError.createUnsupportedError();\n    }\n\n    async hydrateCache(\n        result: AuthenticationResult,\n        request:\n            | SilentRequest\n            | SsoSilentRequest\n            | RedirectRequest\n            | PopupRequest\n    ): Promise<void> {\n        this.logger.verbose(\"hydrateCache called\");\n\n        const accountEntity = AccountEntity.createFromAccountInfo(\n            result.account,\n            result.cloudGraphHostName,\n            result.msGraphHost\n        );\n        this.browserStorage.setAccount(accountEntity);\n        return this.browserStorage.hydrateCache(result, request);\n    }\n}\n"],"mappings":";;;;;;;;;;;;;AAAA;;;AAGG;MAoDUA,uBAAuB;EA4BhCC,YAAYC,gBAA2C;IACnD,IAAI,CAACA,gBAAgB,GAAGA,gBAAgB;IACxC,MAAMC,KAAK,GAAG,IAAI,CAACD,gBAAgB,CAACE,cAAc,EAAE;IACpD,IAAID,KAAK,KAAKE,SAAS,EAAE;MACrB,IAAI,CAACC,WAAW,GAAGH,KAAK;IAC3B,OAAM;MACH,MAAM,IAAII,KAAK,CAAC,sCAAsC,CAAC;IAC1D;;IAGD,IAAI,CAACC,MAAM,GAAGN,gBAAgB,CAACO,SAAS,EAAE;;IAG1C,IAAI,CAACC,MAAM,GAAG,IAAI,CAACR,gBAAgB,CAACS,SAAS,EAAE;;IAG/C,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAACJ,MAAM,CAACK,SAAS,CAACC,MAAM;;IAGrD,IAAI,CAACC,aAAa,GAAGb,gBAAgB,CAACc,oBAAoB,EAAE,GACtD,IAAIC,SAAS,CAAC,IAAI,CAACP,MAAM,EAAE,IAAI,CAACE,iBAAiB,CAAC,GAClDM,6BAA6B;;IAGnC,IAAI,CAACC,cAAc,GAAG,IAAI,CAACjB,gBAAgB,CAACc,oBAAoB,EAAE,GAC5D,IAAII,mBAAmB,CACnB,IAAI,CAACZ,MAAM,CAACa,IAAI,CAACC,QAAQ,EACzB,IAAI,CAACd,MAAM,CAACe,KAAK,EACjB,IAAI,CAACR,aAAa,EAClB,IAAI,CAACL,MAAM,EACXc,2BAA2B,CAAC,IAAI,CAAChB,MAAM,CAACa,IAAI,CAAC,CAChD,GACDI,6BAA6B,CACzB,IAAI,CAACjB,MAAM,CAACa,IAAI,CAACC,QAAQ,EACzB,IAAI,CAACZ,MAAM,CACd;IAEP,IAAI,CAACgB,YAAY,GAAG,IAAIC,YAAY,CAAC,IAAI,CAACjB,MAAM,EAAE,IAAI,CAACK,aAAa,CAAC;IAErE,IAAI,CAACa,oBAAoB,GAAG,IAAIC,oBAAoB,CAChD,IAAI,CAACrB,MAAM,CAACa,IAAI,CAACC,QAAQ,EACzB,IAAI,CAACd,MAAM,CAACa,IAAI,CAACS,kBAAkB,EACnC,IAAI,CAACf,aAAa,EAClB,IAAI,CAACL,MAAM,CACd;;IAGD,MAAMqB,cAAc,GAAG,IAAI,CAACzB,WAAW,CAAC0B,iBAAiB,EAAE;IAC3D,IAAID,cAAc,EAAE;MAChB,MAAME,aAAa,GAAGC,UAAyB,CAC3CH,cAAc,EACd,IAAI,CAACrB,MAAM,EACX,IAAI,CAACS,cAAc,CACtB;MAEDgB,gBAA+B,CAACF,aAAa,EAAE,IAAI,CAACd,cAAc,CAAC;IACtE;;EAGL;;;AAGG;EACHiB,eAAeA,CAAA;IACX,OAAO,IAAI,CAACV,YAAY;;EAG5B;;;;AAIG;EACH,aAAaW,gBAAgBA,CACzBnC,gBAA2C;IAE3C,MAAMoC,UAAU,GAAG,IAAItC,uBAAuB,CAACE,gBAAgB,CAAC;IAChE,OAAOqC,OAAO,CAACC,OAAO,CAACF,UAAU,CAAC;;EAGtC;;;AAGG;EACHG,UAAUA,CAAA;;IAEN,OAAOF,OAAO,CAACC,OAAO,EAAE;;EAG5B;;;;AAIG;EACKE,kBAAkBA,CAMxBC,OAAU;IACR,IAAIA,OAAO,EAAEC,aAAa,EAAE;MACxB,OAAOD,OAAO;IACjB;IACD,OAAO;MACH,GAAGA,OAAO;MACVC,aAAa,EAAE,IAAI,CAAC7B,aAAa,CAAC8B,aAAa;KAClD;;EAGL;;;;AAIG;EACK,MAAMC,uBAAuBA,CACjCH,OAAuC;IAEvC,MAAMI,YAAY,GAAG,IAAI,CAACL,kBAAkB,CAACC,OAAO,CAAC;IAErD,IAAI,CAACjB,YAAY,CAACsB,SAAS,CACvBC,SAAS,CAACC,mBAAmB,EAC7BC,eAAe,CAACC,KAAK,EACrBL,YAAY,CACf;IAED,MAAMM,kBAAkB,GAAG,IAAI,CAACzC,iBAAiB,CAAC0C,gBAAgB,CAC9DC,iBAAiB,CAACC,iBAAiB,EACnCT,YAAY,CAACH,aAAa,CAC7B;IAEDS,kBAAkB,EAAEI,GAAG,CAAC;MAAEC,oBAAoB,EAAE;IAAI,CAAE,CAAC;IAEvD,IAAI;MACA,MAAMC,UAAU,GACZ,IAAI,CAAC/B,oBAAoB,CAACgC,iBAAiB,CAACb,YAAY,CAAC;MAC7D,MAAMc,YAAY,GAAGC,SAAS,CAACC,UAAU,EAAE;MAC3C,MAAMC,QAAQ,GAAG,MAAM,IAAI,CAAC1D,WAAW,CAAC2D,mBAAmB,CACvDN,UAAU,CACb;MACD,MAAMO,MAAM,GACR,IAAI,CAACtC,oBAAoB,CAACuC,oBAAoB,CAC1CR,UAAU,EACVK,QAAQ,EACRH,YAAY,CACf;;MAGL,MAAM,IAAI,CAACO,YAAY,CAACF,MAAM,EAAEvB,OAAO,CAAC;MAExC,IAAI,CAACxB,cAAc,CAACgB,gBAAgB,CAAC+B,MAAM,CAACG,OAAO,CAAC;MACpD,IAAI,CAAC3C,YAAY,CAACsB,SAAS,CACvBC,SAAS,CAACqB,qBAAqB,EAC/BnB,eAAe,CAACC,KAAK,EACrBc,MAAM,CACT;MAEDb,kBAAkB,CAACI,GAAG,CAAC;QACnBc,eAAe,EAAEL,MAAM,CAACM,WAAW,CAACC,MAAM;QAC1CC,WAAW,EAAER,MAAM,CAACS,OAAO,CAACF;MAC/B,EAAC;MAEFpB,kBAAkB,CAACuB,GAAG,CAAC;QACnBC,OAAO,EAAE,IAAI;QACbC,SAAS,EAAEZ,MAAM,CAACY;MACrB,EAAC;MAEF,OAAOZ,MAAM;IAChB,EAAC,OAAOa,CAAC,EAAE;MACR,MAAMC,KAAK,GAAG,IAAI,CAACpD,oBAAoB,CAACqD,eAAe,CAACF,CAAC,CAAC;MAC1D,IAAI,CAACrD,YAAY,CAACsB,SAAS,CACvBC,SAAS,CAACiC,qBAAqB,EAC/B/B,eAAe,CAACC,KAAK,EACrB,IAAI,EACJ2B,CAAe,CAClB;MAED1B,kBAAkB,CAACuB,GAAG,CAClB;QACIC,OAAO,EAAE;OACZ,EACDE,CAAC,CACJ;MAED,MAAMC,KAAK;IACd;;EAGL;;;;AAIG;EACK,MAAMG,0BAA0BA,CACpCxC,OAAsB;IAEtB,MAAMI,YAAY,GAAG,IAAI,CAACL,kBAAkB,CAACC,OAAO,CAAC;IACrD,IAAI,CAACjB,YAAY,CAACsB,SAAS,CACvBC,SAAS,CAACC,mBAAmB,EAC7BC,eAAe,CAACiC,MAAM,EACtBrC,YAAY,CACf;;IAGD,MAAMmB,MAAM,GAAG,MAAM,IAAI,CAACmB,qBAAqB,CAACtC,YAAY,CAAC;IAE7D,IAAImB,MAAM,EAAE;MACR,IAAI,CAACxC,YAAY,CAACsB,SAAS,CACvBC,SAAS,CAACqB,qBAAqB,EAC/BnB,eAAe,CAACiC,MAAM,EACtBlB,MAAM,CACT;MACD,OAAOA,MAAM;IAChB;;IAGD,MAAMoB,oBAAoB,GAAG,IAAI,CAAC1E,iBAAiB,CAAC0C,gBAAgB,CAChEC,iBAAiB,CAACgC,SAAS,EAC3BxC,YAAY,CAACH,aAAa,CAC7B;IAED0C,oBAAoB,EAAEE,SAAS,CAAC;MAC5BC,qBAAqB,EAAE;IAC1B,EAAC;IAEFH,oBAAoB,EAAE7B,GAAG,CAAC;MACtBC,oBAAoB,EAAE;IACzB,EAAC;IAEF,IAAI;MACA,MAAMC,UAAU,GACZ,IAAI,CAAC/B,oBAAoB,CAACgC,iBAAiB,CAACb,YAAY,CAAC;MAC7D,MAAMc,YAAY,GAAGC,SAAS,CAACC,UAAU,EAAE;MAC3C,MAAMC,QAAQ,GAAG,MAAM,IAAI,CAAC1D,WAAW,CAACoF,cAAc,CAAC/B,UAAU,CAAC;MAElE,MAAMO,MAAM,GACR,IAAI,CAACtC,oBAAoB,CAACuC,oBAAoB,CAC1CR,UAAU,EACVK,QAAQ,EACRH,YAAY,CACf;;MAGL,MAAM,IAAI,CAACO,YAAY,CAACF,MAAM,EAAEvB,OAAO,CAAC;MAExC,IAAI,CAACxB,cAAc,CAACgB,gBAAgB,CAAC+B,MAAM,CAACG,OAAO,CAAC;MACpD,IAAI,CAAC3C,YAAY,CAACsB,SAAS,CACvBC,SAAS,CAACqB,qBAAqB,EAC/BnB,eAAe,CAACiC,MAAM,EACtBlB,MAAM,CACT;MACDoB,oBAAoB,EAAE7B,GAAG,CAAC;QACtBc,eAAe,EAAEL,MAAM,CAACM,WAAW,CAACC,MAAM;QAC1CC,WAAW,EAAER,MAAM,CAACS,OAAO,CAACF;MAC/B,EAAC;MACFa,oBAAoB,EAAEV,GAAG,CAAC;QACtBC,OAAO,EAAE,IAAI;QACbC,SAAS,EAAEZ,MAAM,CAACY;MACrB,EAAC;MACF,OAAOZ,MAAM;IAChB,EAAC,OAAOa,CAAC,EAAE;MACR,MAAMC,KAAK,GAAG,IAAI,CAACpD,oBAAoB,CAACqD,eAAe,CAACF,CAAC,CAAC;MAC1D,IAAI,CAACrD,YAAY,CAACsB,SAAS,CACvBC,SAAS,CAACiC,qBAAqB,EAC/B/B,eAAe,CAACiC,MAAM,EACtB,IAAI,EACJL,CAAe,CAClB;MACDO,oBAAoB,EAAEV,GAAG,CACrB;QACIC,OAAO,EAAE;OACZ,EACDE,CAAC,CACJ;MACD,MAAMC,KAAK;IACd;;EAGL;;;;AAIG;EACK,MAAMK,qBAAqBA,CAC/B1C,OAAsB;IAEtB,MAAMgD,cAAc,GAAG,IAAI,CAAC/E,iBAAiB,CAAC0C,gBAAgB,CAC1DC,iBAAiB,CAACqC,kBAAkB,EACpCjD,OAAO,CAACC,aAAa,CACxB;IAED+C,cAAc,EAAElC,GAAG,CAAC;MAChBC,oBAAoB,EAAE;IACzB,EAAC;IAEF,MAAMQ,MAAM,GAAG,MAAM,IAAI,CAAC2B,6BAA6B,CAAClD,OAAO,CAAC;IAEhE,IAAIuB,MAAM,EAAE;MACR,IAAI,CAACxC,YAAY,CAACsB,SAAS,CACvBC,SAAS,CAACqB,qBAAqB,EAC/BnB,eAAe,CAACiC,MAAM,EACtBlB,MAAM,CACT;MACDyB,cAAc,EAAElC,GAAG,CAAC;QAChBc,eAAe,EAAEL,MAAM,EAAEM,WAAW,CAACC,MAAM;QAC3CC,WAAW,EAAER,MAAM,EAAES,OAAO,CAACF;MAChC,EAAC;MACFkB,cAAc,EAAEf,GAAG,CAAC;QAChBC,OAAO,EAAE;MACZ,EAAC;MACF,OAAOX,MAAM;IAChB;IAED,IAAI,CAACxD,MAAM,CAACsE,KAAK,CACb,oFAAoF,CACvF;IAED,IAAI,CAACtD,YAAY,CAACsB,SAAS,CACvBC,SAAS,CAACiC,qBAAqB,EAC/B/B,eAAe,CAACiC,MAAM,EACtB,IAAI,CACP;IACDO,cAAc,EAAEf,GAAG,CAAC;MAChBC,OAAO,EAAE;IACZ,EAAC;IAEF,OAAO,IAAI;;EAGf;;;;AAIG;EACK,MAAMgB,6BAA6BA,CACvClD,OAAsB;IAEtB,MAAMZ,cAAc,GAAG,IAAI,CAACzB,WAAW,CAAC0B,iBAAiB,EAAE;IAC3D,IAAI8D,cAAc,GAAG,IAAI;IACzB,IAAI/D,cAAc,EAAE;MAChB,MAAMgE,UAAU,GAAG7D,UAAyB,CACxCH,cAAc,EACd,IAAI,CAACrB,MAAM,EACX,IAAI,CAACS,cAAc,CACtB;;MAED2E,cAAc,GAAGC,UAAU,IAAIpD,OAAO,CAAC0B,OAAO;IACjD;;IAGD,IAAI,CAACyB,cAAc,EAAE;MACjB,IAAI,CAACpF,MAAM,CAACsF,OAAO,CACf,mDAAmD,CACtD;MACD,OAAOzD,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;IAC/B;IAED,IAAI,CAAC9B,MAAM,CAACsF,OAAO,CACf,4DAA4D,CAC/D;IAED,MAAMC,WAAW,GAAoB;MACjC,GAAGtD,OAAO;MACVC,aAAa,EACTD,OAAO,CAACC,aAAa,IAAI,IAAI,CAAC7B,aAAa,CAAC8B,aAAa,EAAE;MAC/DqD,SAAS,EAAEvD,OAAO,CAACuD,SAAS,IAAIJ,cAAc,CAACK,WAAW;MAC1DC,MAAM,EAAEzD,OAAO,CAACyD,MAAM,EAAE3B,MAAM,GACxB9B,OAAO,CAACyD,MAAM,GACd,CAAC,GAAGC,mBAAmB;KAChC;;IAGD,MAAMC,SAAS,GAAG,IAAI,CAACnF,cAAc,CAACoF,YAAY,EAAE;IACpD,MAAMC,iBAAiB,GAAG,IAAI,CAACrF,cAAc,CAACsF,cAAc,CACxDX,cAAc,EACdG,WAAW,EACXK,SAAS,EACTR,cAAc,CAACY,QAAQ,EACvB,IAAI,CAAC9F,iBAAiB,EACtBqF,WAAW,CAACrD,aAAa,CAC5B;;IAGD,IAAI,CAAC4D,iBAAiB,EAAE;MACpB,IAAI,CAAC9F,MAAM,CAACsF,OAAO,CAAC,8BAA8B,CAAC;MACnD,OAAOzD,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;;IAE/B,OAAM,IACHsB,SAAS,CAAC6C,kBAAkB,CAACH,iBAAiB,CAACI,QAAQ,CAAC,IACxD9C,SAAS,CAAC+C,cAAc,CACpBL,iBAAiB,CAACM,SAAS,EAC3B,IAAI,CAACtG,MAAM,CAACuG,MAAM,CAACC,yBAAyB,CAC/C,EACH;MACE,IAAI,CAACtG,MAAM,CAACsF,OAAO,CACf,yEAAyE,CAC5E;MACD,MAAMiB,aAAa,GACfC,aAAa,CAACC,qBAAqB,CAACrB,cAAc,CAAC;MACvD,MAAM,IAAI,CAAC3E,cAAc,CAACiG,oBAAoB,CAACH,aAAa,CAAC;MAC7D,OAAO1E,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;IAC/B;IAED,MAAM6E,aAAa,GAAG,IAAI,CAAClG,cAAc,CAACmG,UAAU,CAChDxB,cAAc,EACdQ,SAAS,EACTR,cAAc,CAACY,QAAQ,EACvB,IAAI,CAAC9F,iBAAiB,EACtBqF,WAAW,CAACrD,aAAa,CAC5B;IAED,IAAI,CAACyE,aAAa,EAAE;MAChB,IAAI,CAAC3G,MAAM,CAACsF,OAAO,CAAC,0BAA0B,CAAC;MAC/C,OAAOzD,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;IAC/B;IAED,OAAO,IAAI,CAACZ,oBAAoB,CAAC2F,+BAA+B,CAC5DzB,cAAc,EACduB,aAAa,EACbb,iBAAiB,EACjBP,WAAW,EACXA,WAAW,CAACrD,aAAa,CAC5B;;EAGL;;;;AAIG;EACH,MAAM4E,iBAAiBA,CACnB7E,OAAqB;IAErB,OAAO,IAAI,CAACG,uBAAuB,CAACH,OAAO,CAAC;;EAGhD;;;AAGG;;EAEH8E,oBAAoBA,CAAC9E,OAAwB;IACzC,MAAM+E,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrD;;;;AAIG;EACH,MAAMC,kBAAkBA,CACpBC,aAA4B;IAE5B,OAAO,IAAI,CAAC1C,0BAA0B,CAAC0C,aAAa,CAAC;;EAGzD;;;AAGG;;EAEHC,kBAAkBA,CACdnF,OAAiC;EAAA,E;IAEjC,MAAM+E,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrD;;;;;AAKG;EACHI,kBAAkBA,CACdpF,OAYkB,EAClBqF,KAAY;EAAA;EACZC,SAA8B;EAAA,E;IAE9B,MAAMP,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrD;;;;AAIG;EACHO,0BAA0BA,CACtBC,aAAsC;EAAA;EACtCN,aAA4B;EAAA,E;IAE5B,MAAMH,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrD;;;AAGG;EACHS,gBAAgBA,CAACC,QAA+B;IAC5C,OAAO,IAAI,CAAC3G,YAAY,CAAC0G,gBAAgB,CAACC,QAAQ,CAAC;;EAGvD;;;AAGG;EACHC,mBAAmBA,CAACC,UAAkB;IAClC,IAAI,CAAC7G,YAAY,CAAC4G,mBAAmB,CAACC,UAAU,CAAC;;;EAIrDC,sBAAsBA,CAACH,QAAqC;IACxD,MAAMX,kBAAkB,CAACC,sBAAsB,EAAE;;;EAIrDc,yBAAyBA,CAACF,UAAkB;IACxC,MAAMb,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrDe,0BAA0BA,CAAA;IACtB,MAAMhB,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrDgB,2BAA2BA,CAAA;IACvB,MAAMjB,kBAAkB,CAACC,sBAAsB,EAAE;;;EAKrD;;;;AAIG;EACHiB,cAAcA,CAACC,aAA6B;IACxC,OAAOD,cAA6B,CAChC,IAAI,CAAClI,MAAM,EACX,IAAI,CAACS,cAAc,EACnB,IAAI,CAAC2H,YAAY,EAAE,EACnBD,aAAa,CAChB;;EAGL;;;;AAIG;EACH3G,UAAUA,CAAC2G,aAA4B;IACnC,OAAO3G,UAAyB,CAC5B2G,aAAa,EACb,IAAI,CAACnI,MAAM,EACX,IAAI,CAACS,cAAc,CACtB;;EAGL;;;;;;;AAOG;EACH4H,oBAAoBA,CAACC,QAAgB;IACjC,OAAOD,oBAAmC,CACtCC,QAAQ,EACR,IAAI,CAACtI,MAAM,EACX,IAAI,CAACS,cAAc,CACtB;;EAGL;;;;;;AAMG;EACH8H,kBAAkBA,CAACC,aAAqB;IACpC,OAAOD,kBAAiC,CACpCC,aAAa,EACb,IAAI,CAACxI,MAAM,EACX,IAAI,CAACS,cAAc,CACtB;;EAGL;;;;;;AAMG;EACHgI,mBAAmBA,CAACC,cAAsB;IACtC,OAAOD,mBAAkC,CACrCC,cAAc,EACd,IAAI,CAAC1I,MAAM,EACX,IAAI,CAACS,cAAc,CACtB;;EAGL;;;AAGG;EACHgB,gBAAgBA,CAACkC,OAA2B;IACxC;;;AAGG;IACH,OAAOlC,gBAA+B,CAACkC,OAAO,EAAE,IAAI,CAAClD,cAAc,CAAC;;EAGxE;;AAEG;EACHkI,gBAAgBA,CAAA;IACZ,OAAOA,gBAA+B,CAAC,IAAI,CAAClI,cAAc,CAAC;;;EAK/DmI,qBAAqBA,CACjBC,IAAyB;EAAA,E;IAEzB,OAAOhH,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;;EAEhCgH,UAAUA,CACN7G,OAAkC;EAAA,E;IAElC,OAAO,IAAI,CAACG,uBAAuB,CAACH,OAAO,IAAI8G,eAAe,CAAC;;;EAGnEC,aAAaA,CAAC/G,OAAqC;IAC/C,MAAM+E,kBAAkB,CAACC,sBAAsB,EAAE;;;EAGrDgC,MAAMA,CAACC,aAA6C;IAChD,MAAMlC,kBAAkB,CAACC,sBAAsB,EAAE;;EAErDkC,cAAcA,CACVD,aAA6C;EAAA,E;IAE7C,MAAMlC,kBAAkB,CAACC,sBAAsB,EAAE;;EAErDmC,WAAWA,CACPF,aAAkD;EAAA,E;IAElD,MAAMlC,kBAAkB,CAACC,sBAAsB,EAAE;;EAErDoC,SAASA;;EAELpH,OASC;IAED,OAAO,IAAI,CAACwC,0BAA0B,CAACxC,OAAwB,CAAC;;EAEpEqH,aAAaA,CAAA;IACT,MAAMtC,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrD;;AAEG;EACIhH,SAASA,CAAA;IACZ,OAAO,IAAI,CAACD,MAAM;;EAGtB;;;AAGG;EACHuJ,SAASA,CAACvJ,MAAc;IACpB,IAAI,CAACA,MAAM,GAAGA,MAAM;;;EAIxBwJ,wBAAwBA,CAACC,GAAe,EAAEC,OAAe;IACrD;;;AAGG;IACH;;;EAIJC,mBAAmBA,CAACC,gBAAmC;IACnD,IAAI,CAAC5J,MAAM,CAAC6J,OAAO,CACf,yDAAyD,CAC5D;;EAGLC,gBAAgBA,CAAA;IACZ,OAAO,IAAI,CAAChK,MAAM;;EAGtBsI,YAAYA,CAAA;IACR,OAAO,IAAI,CAAC5I,gBAAgB,CAACc,oBAAoB,EAAE;;EAGvDyJ,gBAAgBA,CAAA;IACZ,OAAO,IAAI,CAAC1J,aAAa;;EAG7B2J,oBAAoBA,CAAA;IAChB,MAAMhD,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrDgD,mBAAmBA,CAAA;IACf,MAAMjD,kBAAkB,CAACC,sBAAsB,EAAE;;;EAIrD,MAAMiD,UAAUA,CAAChB,aAAiC;IAC9C,MAAMlC,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrD,MAAMvD,YAAYA,CACdF,MAA4B,EAC5BvB,OAIkB;IAElB,IAAI,CAACjC,MAAM,CAACsF,OAAO,CAAC,qBAAqB,CAAC;IAE1C,MAAMiB,aAAa,GAAGC,aAAa,CAACC,qBAAqB,CACrDjD,MAAM,CAACG,OAAO,EACdH,MAAM,CAAC2G,kBAAkB,EACzB3G,MAAM,CAAC4G,WAAW,CACrB;IACD,IAAI,CAAC3J,cAAc,CAAC4J,UAAU,CAAC9D,aAAa,CAAC;IAC7C,OAAO,IAAI,CAAC9F,cAAc,CAACiD,YAAY,CAACF,MAAM,EAAEvB,OAAO,CAAC;;AAE/D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}